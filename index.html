<!DOCTYPE html>
<html>

<head>
    <script type="text/javascript">
        let fps = 60
        let msPerFrame = 1000 / fps;
        let maxInvaderSpeedPerFrame = 150.0 / fps;
        let maxInvaderAccelPerFrame = 70.0 / fps;
        let minInvaderSpeedPerFrame = 1.0 / fps;
        let maxInvaderRotPerFrame = Math.PI / fps;
        let maxEvaderSpeedPerFrame = maxInvaderSpeedPerFrame;
        let maxEvaderAccelPerFrame = maxInvaderAccelPerFrame;
        let minEvaderSpeedPerFrame = minInvaderSpeedPerFrame;
        let maxEvaderRotPerFrame = maxInvaderRotPerFrame;
        let bulletSpeed = 500.0 / fps;
        let bulletPoolSize = 100;
        let bulletSize = 10;

        let framesToCountAsHit = fps / 4
        let queueSize = 60
        let queuePeriod = 2
        let networkBehaviorUpdatePeriod = fps / 4

        let xRange = [0, 400]
        let yRange = [0, 400]

        let annNodeSize = 15;
        let frameNumber = 0;
        let playerColor = "green"
        let enemyColor = "blue"
        let networkDrawState;
        let networkUpdateUI = 1
        let gunCooldown = fps / 5

        class Node {
            constructor(layerIdx, layerNodeIdx) {
                this.layerIdx = layerIdx;
                this.layerNodeIdx = layerNodeIdx;
            }

            toString() {
                return this.layerIdx + "/" + this.layerNodeIdx
            }
        }

        class Link {
            constructor(src, dst, weight) {
                this.src = src;
                this.dst = dst;
                this.weight = weight;
            }

            toString() {
                return this.src.toString() + "-(" + this.weight + ")->" + this.dst.toString()
            }
        }

        class Network {
            // nodes is [], nodes[x] is node k from any layerIdx, its a function-lambda
            // layerIdxs [], layerIdxs[x] is amount of nodes in layerIdx x, sum of layerIdxs should be equal to nodes length
            // links is [[], ], links[x][y] is link from x to y if present
            constructor(middleLayerIdxFunction, outputLayerIdxFunction, layers, links) {
                this.middleLayerIdxFunction = middleLayerIdxFunction;
                this.outputLayerIdxFunction = outputLayerIdxFunction;
                this.layers = layers;
                this.links = links;
                this.trainInputQueue = [];
                this.trainInputQueueBusy = false;
                this.trainInputQueueIdx = 0;
                for (let i = 0; i < queueSize; i++) {
                    this.trainInputQueue.push(undefined)
                }
            }

            getNodeLayer(id) {
                let skipped = 0
                for (let layerIdx = 0; layerIdx < this.layers.length; layerIdx++) {
                    let layerSize = this.layers[layerIdx]
                    if (id < skipped + layerSize) {
                        return { "layerIdx": layerIdx, "layerNodeIdx": (id - skipped) }
                    }
                    skipped += layerSize
                }
            }

            makeInput(invaderShip, evaderShip) {
                /*
                 inputs to network:
                 distance
                 angle from my front direction to player vector
                 angle from player front direction to player vector
                 self acceleration on/off
                 self self rotation on/off
                 */
                let invader = invaderShip.shipBase;
                let evader = evaderShip.shipBase;
                let distance = Math.sqrt(Math.pow(invader.pos.x - evader.pos.x, 2)
                    + Math.pow(invader.pos.y - evader.pos.y, 2)) / bulletSpeed;
                let angleAtInvader = Math.atan2(invader.pos.y - evader.pos.y, invader.pos.x - evader.pos.x)
                while (angleAtInvader >= Math.PI * 2) { angleAtInvader -= Math.PI * 2; }
                while (angleAtInvader < 0) { angleAtInvader += Math.PI * 2; }

                let evaderAway = angleAtInvader - evader.rot
                while (evaderAway >= Math.PI * 2) { evaderAway -= Math.PI * 2; }
                while (evaderAway < 0) { evaderAway += Math.PI * 2; }

                let invaderAway = invader.rot + (Math.PI - angleAtInvader)
                while (invaderAway >= Math.PI * 2) { invaderAway -= Math.PI * 2; }
                while (invaderAway < 0) { invaderAway += Math.PI * 2; }

                let accel = evader.acceleratorOn
                let rot = evaderShip.rotationOn

                let input = [distance, evaderAway, invaderAway, accel, rot]
                // console.log("Queueing" +
                //     " distance=" + distance +
                //     ", evaderAway=" + evaderAway +
                //     ", invaderAway=" + invaderAway +
                //     ", accel=" + accel +
                //     ", rot=" + rot)
                return input;
            }

            queueInput(invaderShip, evaderShip) {
                if (this.trainInputQueueBusy) return;
                let input = this.makeInput(invaderShip, evaderShip)
                for (let i = 0; i < input.length; i++) if (input[i] == null) throw new Error("bad network queue input")

                if (this.trainInputQueueIdx == 0) {
                    let previousValue = this.trainInputQueue[this.trainInputQueueIdx]
                    this.trainSingle(previousValue, -1)
                }
                this.trainInputQueue[this.trainInputQueueIdx] = input
                this.trainInputQueueIdx = (this.trainInputQueueIdx + 1) % queueSize
            }

            trainSingle(input, result) {
                if (input === undefined) return;
                let networkResult = this.calc(input)
                console.log("Network result " + networkResult + " expected result " + result)
                if (networkResult[2][0] == result) {
                    console.log("No error, no updates to network")
                    return;
                }
                let updates = 0
                for (let secondLayerIdx = 0; secondLayerIdx < this.layers[1]; secondLayerIdx++) {

                    let secondLayerNodeValue = 0;
                    for (let linkIdx = 0; linkIdx < this.links.length; linkIdx++) {
                        let link = this.links[linkIdx]
                        if (link.src.layerIdx == 0 && link.dst.layerIdx == 1
                            && link.dst.layerNodeIdx == secondLayerIdx) {
                            secondLayerNodeValue += link.weight * input[link.src.layerNodeIdx]
                        }
                    }
                    //console.log("train single idx=" + secondLayerIdx + " value=" + secondLayerNodeValue + " middleValue=" + this.middleLayerIdxFunction(secondLayerNodeValue))
                    if (this.middleLayerIdxFunction(secondLayerNodeValue) > 0) {
                        for (let linkIdx = 0; linkIdx < this.links.length; linkIdx++) {
                            let link = this.links[linkIdx]
                            if (link.src.layerIdx == 1 && link.dst.layerIdx == 2
                                && link.src.layerNodeIdx == secondLayerIdx) {
                                link.weight += result
                                updates = 1
                                console.log(link.toString() + " weight readjusted")
                            }
                        }
                    }
                }
                networkUpdateUI += updates * fps / 2
            }

            trainOnLastEventsAsDeath(lastEventCount) {
                this.trainInputQueueBusy = true
                let smallQueue = [];
                for (let i = 0; i < lastEventCount; i++) {
                    smallQueue.push(this.trainInputQueue.shift())
                }
                this.trainInputQueueBusy = false
                for (let i = 0; i < lastEventCount; i++) {
                    this.trainSingle(smallQueue.shift(), 1)
                }
            }

            calc(input) {
                if (input.length != this.layers[0]) {
                    console.log("Bad input. Need array of length " + this.layers[0] + ". Got " + input.length)
                    return
                }
                for (let i = 0; i < input.length; i++) if (input[i] == null) throw new Error("bad network calc input")

                let secondLayerValues = []
                for (let secondLayerIdx = 0; secondLayerIdx < this.layers[1]; secondLayerIdx++) {

                    let secondLayerNodeValue = 0;
                    for (let linkIdx = 0; linkIdx < this.links.length; linkIdx++) {
                        let link = this.links[linkIdx]
                        if (link.src.layerIdx == 0 && link.dst.layerIdx == 1
                            && link.dst.layerNodeIdx == secondLayerIdx) {
                            secondLayerNodeValue += link.weight * input[link.src.layerNodeIdx]
                        }
                    }
                    secondLayerValues.push(this.middleLayerIdxFunction(secondLayerNodeValue))
                }

                let networkResult = 0;
                for (let layerIdx = 0; layerIdx < this.layers[2]; layerIdx++) {

                    let inSignal = 0;
                    for (let linkIdx = 0; linkIdx < this.links.length; linkIdx++) {
                        let link = this.links[linkIdx]
                        if (link.src.layerIdx == 1 && link.dst.layerIdx == 2
                            && link.dst.layerNodeIdx == layerIdx) {
                            inSignal += link.weight * secondLayerValues[link.src.layerNodeIdx]
                        }
                    }
                    networkResult = this.outputLayerIdxFunction(inSignal)
                }
                return [input, secondLayerValues, [networkResult]]
            }
        }

        class BulletPool {
            // nodes is [], nodes[x] is node k from any layerIdx, its a function-lambda
            // layerIdxs [], layerIdxs[x] is amount of nodes in layerIdx x, sum of layerIdxs should be equal to nodes length
            // links is [[], ], links[x][y] is link from x to y if present
            constructor(poolSize, color) {
                this.bullets = [];
                this.poolSize = poolSize;
                this.bulletPoolIdx = 0;
                for (let i = 0; i < this.poolSize; i++) {
                    this.bullets.push(new Bullet(-100, -100, 0, 0, "black"))
                }
            }

            getBullet(pos, vel, rot) {
                let b = this.bullets[this.bulletPoolIdx];
                this.bulletPoolIdx = (this.bulletPoolIdx + 1) % this.poolSize;
                b.pos.x = pos.x
                b.pos.y = pos.y
                b.vel.x = vel.x + bulletSpeed * Math.cos(rot);
                b.vel.y = vel.y + bulletSpeed * Math.sin(rot);
                return b
            }
        }

        class Bullet {
            constructor(x, y, velX, velY, color) {
                this.pos = { "x": x, "y": y };
                this.vel = { "x": velX, "y": velY };
                this.size = bulletSize;
                this.fillStyle = color;
            }

            vanish() {
                this.pos = { "x": -100, "y": -100 };
                this.vel = { "x": 0, "y": 0 };
            }
        }

        class ShipBase {
            constructor(x, y, rot, color) {
                this.pos = { "x": x, "y": y };
                this.vel = { "x": 0, "y": 0 };
                this.rot = 0;
                this.acceleratorOn = 0;
                this.fillStyle = color;
            }
        }

        class EvaderShip {
            constructor(shipBase) {
                this.shipBase = shipBase;
                this.rotationOn = 0;
                this.wasHit = false;
            }
        }

        class PlayerShip {
            constructor(shipBase) {
                this.shipBase = shipBase;
                this.targetRot = 0;
                this.gun = {
                    "pressed": 0,
                    "cooldown": 0
                };
            }
        }

        function normalizeAngle(value) {
            while (value >= Math.PI * 2) {
                value -= Math.PI * 2;
            }
            while (value < 0) {
                value += Math.PI * 2;
            }
            return value;
        }

        function angleMoveLimited(angle1, angle2, limit) {
            let rawDistance = angle2 - angle1;
            let distanceReverse = (Math.PI * 2 - Math.abs(rawDistance)) * (-Math.sign(rawDistance))
            let result = 0;
            if (Math.abs(rawDistance) < Math.abs(distanceReverse)) {
                result = rawDistance;
            } else {
                result = distanceReverse;
            }
            return Math.sign(result) * Math.min(limit, Math.abs(result))
        }

        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        function confine(value, range) {
            if (value > range[1]) {
                return [range[1], true];
            } else if (value < range[0]) {
                return [range[0], true];
            } else {
                return [value, false];
            }
        }

        function chooseEvaderBehavior(invader, evader, evaderNetwork) {
            let options = [[0, 0], [0, 1], [0, -1], [1, 0], [1, 1], [1, -1]]
            // let options = [[1, 0], [1, 1], [1, -1]] //this is debug
            let optionIdx;
            let results = [];
            for (optionIdx = 0; optionIdx < options.length; optionIdx++) {
                let input = evaderNetwork.makeInput(invader, evader)
                input[3] = options[optionIdx][0]
                input[4] = options[optionIdx][1]
                let output = evaderNetwork.calc(input);
                results.push(output)
                let result = output[2][0]
                if (result < 0) {
                    console.log("Using NON random behavior")
                    break;
                }
            }
            if (optionIdx >= options.length) {
                optionIdx = getRandomInt(0, options.length - 1)
                console.log("Using random behavior " + options[optionIdx][0] + " " + options[optionIdx][1])
            }
            networkDrawState = results[optionIdx];
            evader.shipBase.acceleratorOn = options[optionIdx][0]
            evader.rotationOn = options[optionIdx][1]
        }


        let evaderNetwork = new Network(
            (input) => (Math.sign(input) + 1) / 2,
            (input) => Math.sign(input),
            [5, 6, 1],
            [
                new Link(new Node(0, 0), new Node(1, 0), 1),
                new Link(new Node(0, 0), new Node(1, 1), -1),

                new Link(new Node(0, 1), new Node(1, 0), 1),
                new Link(new Node(0, 1), new Node(1, 1), 1),
                new Link(new Node(0, 1), new Node(1, 2), -1),

                new Link(new Node(0, 2), new Node(1, 1), 1),
                new Link(new Node(0, 2), new Node(1, 2), 1),
                new Link(new Node(0, 2), new Node(1, 3), -1),

                new Link(new Node(0, 3), new Node(1, 2), 1),
                new Link(new Node(0, 3), new Node(1, 3), 1),
                new Link(new Node(0, 3), new Node(1, 4), -1),

                new Link(new Node(0, 4), new Node(1, 3), 1),
                new Link(new Node(0, 4), new Node(1, 4), 1),
                new Link(new Node(0, 4), new Node(1, 5), -1),

                new Link(new Node(1, 0), new Node(2, 0), 1),
                new Link(new Node(1, 1), new Node(2, 0), 1),
                new Link(new Node(1, 2), new Node(2, 0), 1),
                new Link(new Node(1, 3), new Node(2, 0), 1),
                new Link(new Node(1, 4), new Node(2, 0), 1),
                new Link(new Node(1, 5), new Node(2, 0), 1)
            ]
        )

        const accelStart = (e) => {
            switch (e.key) {
                case 'a':
                    //invader.accel.x.negative = 1;
                    break;
                case 'd':
                    //invader.accel.x.positive = 1;
                    break;
                case 'w':
                    invader.shipBase.acceleratorOn = 1;
                    break;
                case 's':
                    //invader.accel.y.negative = 1;
                    break;
                case 'q':
                case ' ':
                    invader.gun.pressed = 1;
                    break;
            }
        };

        const accelStop = (e) => {
            switch (e.key) {
                case 'a':
                    //invader.accel.x.negative = 0;
                    break;
                case 'd':
                    // invader.accel.x.positive = 0;
                    break;
                case 'w':
                    invader.shipBase.acceleratorOn = 0;
                    break;
                case 's':
                    //invader.accel.y.negative = 0;
                    break;
                case 'q':
                case ' ':
                    invader.gun.pressed = 0;
                    break;
            }
        };


        var mouse_pos = { "x": 0, "y": 0 };

        var invader = new PlayerShip(new ShipBase(150, 200, 0, playerColor))
        var evader = new EvaderShip(new ShipBase(300, 300, 0, enemyColor))

        var playerBulletPool = new BulletPool(bulletPoolSize, "black")
        var bulletPoolIdx = 0

        function drawShip(ctx, ship) {
            //console.log(ship)
            ctx.save();
            ctx.translate(ship.pos.x, ship.pos.y);

            ctx.rotate(ship.rot);

            ctx.fillStyle = ship.fillStyle;
            var path = new Path2D();
            path.moveTo(30, 0);
            path.lineTo(-30, -20);
            path.lineTo(-20, 0);
            path.lineTo(-30, 20);
            ctx.fill(path);

            if (ship.acceleratorOn) {

                ctx.fillStyle = "orange";
                var path = new Path2D();
                path.moveTo(-20, 0);
                path.lineTo(-28, -16);
                path.lineTo(-35, -10);
                path.lineTo(-33, -8);
                path.lineTo(-40, 0);
                path.lineTo(-33, +8);
                path.lineTo(-35, +10);
                path.lineTo(-28, +16);
                ctx.fill(path);

                ctx.fillStyle = "yellow";
                var path = new Path2D();
                path.moveTo(-20, 0);
                path.lineTo(-28, -4);
                path.lineTo(-36, 0);
                path.lineTo(-28, +4);
                ctx.fill(path);
            }
            ctx.restore();
        }

        function drawBullet(ctx, bullet) {
            //console.log(bullet)
            ctx.save();
            ctx.translate(bullet.pos.x, bullet.pos.y);
            ctx.beginPath()
            ctx.arc(0, 0, bullet.size, 0, Math.PI * 2, false);
            ctx.fillStyle = bullet.fillStyle;

            //stroke will draw the circle
            ctx.fill()
            ctx.restore()
        }

        function drawUpdating(ctx, canvas) {
            // set line stroke and line width
            ctx.strokeStyle = 'orange';
            ctx.lineWidth = Math.min(10, networkUpdateUI / 10);

            // draw a red line
            ctx.beginPath();
            ctx.moveTo(2, 2);
            ctx.lineTo(canvas.width - 2, 2);
            ctx.lineTo(canvas.width - 2, canvas.height - 2);
            ctx.lineTo(2, canvas.height - 2);
            ctx.stroke();
        }

        function drawBorder(ctx, canvas) {
            // set line stroke and line width
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;

            // draw a red line
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(canvas.width, 0);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.stroke();
        }

        function drawFrame() {

            // get the canvas element using the DOM
            var canvas = document.getElementById('frame-canvas');
            var dimension = [document.getElementById("frame-div").offsetWidth, document.getElementById("frame-div").offsetHeight];

            canvas.width = dimension[0];
            canvas.height = dimension[1];

            // Make sure we don't execute when canvas isn't supported
            if (canvas.getContext) {

                // use getContext to use the canvas for drawing
                var ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.font = "10px Arial";
                ctx.fillText("Frame: " + frameNumber, 0, 10);
                ctx.transform(1, 0, 0, -1, 0, canvas.height) // flip y    

                //drawBorder(ctx, canvas);

                drawShip(ctx, invader.shipBase);
                drawShip(ctx, evader.shipBase);
                for (let i = 0; i < playerBulletPool.bullets.length; i++) {
                    drawBullet(ctx, playerBulletPool.bullets[i]);
                }
            } else {
                alert('Canvas.getContext not supported in your browser');
            }
        }

        function drawNetwork() {

            // get the canvas element using the DOM
            var canvas = document.getElementById('network-canvas');
            var dimension = [document.getElementById("network-div").offsetWidth, document.getElementById("network-div").offsetHeight];

            canvas.width = dimension[0];
            canvas.height = dimension[1];

            // Make sure we don't execute when canvas isn't supported
            if (canvas.getContext) {

                // use getContext to use the canvas for drawing
                var ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // ctx.transform(1, 0, 0, -1, 0, canvas.height) // flip y

                //drawBorder(ctx, canvas);
                //console.log("networkUpdateUI=" + networkUpdateUI)
                if (networkUpdateUI > 0) {
                    networkUpdateUI -= 1
                    drawUpdating(ctx, canvas)
                }

                let network = evaderNetwork;
                for (var layerIdx = 0; layerIdx < network.layers.length; layerIdx++) {
                    let xShift = 100 * (layerIdx + 1)
                    for (var layerNodeIdx = 0; layerNodeIdx < network.layers[layerIdx]; layerNodeIdx++) {
                        let yShift = 50 * (layerNodeIdx + 1)
                        // console.log("draw node " + layerIdx + ":" + layerNodeIdx)
                        drawBullet(ctx, {
                            "pos": { "x": xShift, "y": yShift },
                            "size": annNodeSize,
                            "fillStyle": "black"
                        })
                        let calcValue = Math.floor(networkDrawState[layerIdx][layerNodeIdx] * 10) / 10
                        ctx.font = "10px Arial";
                        ctx.fillText("" + calcValue, xShift, yShift + 10 + annNodeSize);
                    }
                }

                for (var linkIdx = 0; linkIdx < network.links.length; linkIdx++) {
                    let link = network.links[linkIdx]
                    let from = link.src
                    let to = link.dst

                    // set line stroke and line width
                    ctx.strokeStyle = 'black';
                    let linkLog = Math.max(0, Math.log(Math.abs(link.weight * 5)) + 1)
                    // console.log("linkIdx=" + linkIdx +
                    //     " link.weight=" + link.weight +
                    //     " width=" + linkLog)
                    if (link.weight != 0 && linkLog > 3) {
                        if (Math.sign(link.weight) > 0) {
                            ctx.strokeStyle = 'green';
                        } else {
                            ctx.strokeStyle = 'red';
                        }
                    }
                    if (linkLog == 0) {
                        ctx.setLineDash([5, 3]);
                        linkLog = 2;
                    } else {
                        ctx.setLineDash([]);
                    }
                    ctx.lineWidth = linkLog;

                    // draw a red line
                    ctx.beginPath();
                    let xShift = 100 * (from.layerIdx + 1) + annNodeSize
                    let yShift = 50 * (from.layerNodeIdx + 1)
                    ctx.moveTo(xShift, yShift);
                    xShift = 100 * (to.layerIdx + 1) - annNodeSize
                    yShift = 50 * (to.layerNodeIdx + 1)
                    ctx.lineTo(xShift, yShift);
                    ctx.stroke();
                }
            } else {
                alert('Canvas.getContext not supported in your browser');
            }
        }

        function getMousePos(canvas, evt) {
            var rect = canvas.getBoundingClientRect(), // abs. size of element
                scaleX = canvas.width / rect.width,    // relationship bitmap vs. element for x
                scaleY = canvas.height / rect.height;  // relationship bitmap vs. element for y

            return {
                x: (evt.clientX - rect.left) * scaleX,   // scale mouse coordinates after they have
                y: rect.height - (evt.clientY - rect.top) * scaleY     // been adjusted to be relative to element
            }
        }

        let handleMousemove = (event) => {
            var shipCanvas = document.getElementById('frame-canvas');
            let mouseCanvas = getMousePos(shipCanvas, event)
            mouse_pos.x = mouseCanvas.x;
            mouse_pos.y = mouseCanvas.y;
            //reverse y as canvas has y 0 in the bottom left
            invader.targetRot = Math.atan2(mouseCanvas.y - invader.shipBase.pos.y, mouseCanvas.x - invader.shipBase.pos.x)
        };

        let throttle = (func, delay) => {
            let prev = Date.now() - delay;
            return (...args) => {
                let current = Date.now();
                if (current - prev >= delay) {
                    prev = current;
                    func.apply(null, args);
                }
            }
        };

        function getBullet(pos, vel, rot) {
            let b = bullets[bulletPoolIdx];
            bulletPoolIdx = (bulletPoolIdx + 1) % bulletPoolSize;
            b.pos.x = pos.x
            b.pos.y = pos.y
            b.vel.x = vel.x + bulletSpeed * Math.cos(rot);
            b.vel.y = vel.y + bulletSpeed * Math.sin(rot);
            return b
        }

        function handleGun(ship) {
            if (ship.gun.cooldown > 0) ship.gun.cooldown -= 1
            if (ship.gun.pressed && !ship.gun.cooldown) {
                let bullet = playerBulletPool.getBullet(ship.shipBase.pos, ship.shipBase.vel, ship.shipBase.rot)
                ship.gun.cooldown = gunCooldown
            }
        }

        function handleShipBase(shipBase) {
            let accel_x = shipBase.acceleratorOn * Math.cos(shipBase.rot) * maxInvaderAccelPerFrame
            let accel_y = shipBase.acceleratorOn * Math.sin(shipBase.rot) * maxInvaderAccelPerFrame
            shipBase.vel.x += accel_x
            shipBase.vel.y += accel_y
            shipBase.pos.x += shipBase.vel.x
            shipBase.pos.y += shipBase.vel.y
            shipBase.vel.x *= 0.95
            shipBase.vel.y *= 0.95

            if (Math.abs(shipBase.vel.x) < minInvaderSpeedPerFrame) shipBase.vel.x = 0
            if (Math.abs(shipBase.vel.y) < minInvaderSpeedPerFrame) shipBase.vel.y = 0

            shipBase.vel.x = Math.max(-maxInvaderSpeedPerFrame, Math.min(maxInvaderSpeedPerFrame, shipBase.vel.x));
            shipBase.vel.y = Math.max(-maxInvaderSpeedPerFrame, Math.min(maxInvaderSpeedPerFrame, shipBase.vel.y));
            let xConfined = confine(shipBase.pos.x, xRange)
            let yConfined = confine(shipBase.pos.y, yRange)
            shipBase.pos.x = xConfined[0]
            shipBase.pos.y = yConfined[0]
            if (xConfined[1] || yConfined[1]) {
                shipBase.acceleratorOn = 0
            }
        }

        function handleInvader(invader) {
            let shipBase = invader.shipBase;
            handleShipBase(shipBase)

            invader.targetRot = Math.atan2(mouse_pos.y - shipBase.pos.y, mouse_pos.x - shipBase.pos.x)
            shipBase.rot += angleMoveLimited(normalizeAngle(shipBase.rot), normalizeAngle(invader.targetRot), maxInvaderRotPerFrame)

            handleGun(invader)
        }

        function handleEvader(evader) {
            let shipBase = evader.shipBase;
            handleShipBase(shipBase)
            shipBase.rot += evader.rotationOn * maxInvaderRotPerFrame;
        }

        function handleBullet(bullet) {
            bullet.pos.x += bullet.vel.x
            bullet.pos.y += bullet.vel.y
        }

        function handleBulletHitEvader(bulletPool) {
            for (let i = 0; i < bulletPool.poolSize; i++) {
                let b = bulletPool.bullets[i]
                if (Math.abs(evader.shipBase.pos.x - b.pos.x) < b.size
                    && Math.abs(evader.shipBase.pos.y - b.pos.y) < b.size) {
                    // evader was hit
                    b.vanish()
                    evaderNetwork.trainOnLastEventsAsDeath(framesToCountAsHit)
                    break;
                }
            }
        }

        function logicFrame() {
            if (frameNumber % queuePeriod == 0) {
                evaderNetwork.queueInput(invader, evader);
            }
            if (frameNumber % networkBehaviorUpdatePeriod == 0) {
                chooseEvaderBehavior(invader, evader, evaderNetwork)
            }
            handleInvader(invader)
            handleEvader(evader)

            for (let i = 0; i < playerBulletPool.bullets.length; i++) {
                handleBullet(playerBulletPool.bullets[i]);
            }

            handleBulletHitEvader(playerBulletPool)
        }

        function frame() {
            frameNumber++;
            logicFrame()
            drawFrame()

            evader.rot -= 2 * Math.PI / 60 / 60;
            drawNetwork()
        }

        function animate() {
            setInterval(() => { frame() }, msPerFrame);
            window.addEventListener('keydown', accelStart);
            window.addEventListener('keyup', accelStop);
            document.addEventListener('mousemove', throttle(handleMousemove, msPerFrame));
        }
    </script>
</head>

<body onload="animate();">
    <div id="instruction-div" style="width: 400px;">
        Try to kill the blue guy as much as you can, but it will learn.
        Use W to move, Q or Space to shoot. Mouse to rotate.
    </div>
    <div id="frame-div" style="width: 400px; height: 400px;">
        <canvas id="frame-canvas" style="border:1px solid #000000;"></canvas>
    </div>
    <div id="network-div" style="width: 400px; height: 400px;">
        <canvas id="network-canvas" style="border:1px solid #000000;"></canvas>
    </div>
</body>

</html>