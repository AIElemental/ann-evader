<!DOCTYPE html>
<html>

<head>
    <script type="text/javascript">
        let fps = 60
        let msPerFrame = 1000 / fps;
        let maxInvaderSpeedPerFrame = 150.0 / fps;
        let maxInvaderAccelPerFrame = 70.0 / fps;
        let maxInvaderDecelRatePerFrame = 10.0 / fps;
        let minInvaderSpeedPerFrame = 4.0 / fps;
        let bulletSpeed = 500.0 / fps;
        let bulletPoolSize = 100;
        let bulletSize = 10;

        let annNodeSize = 15;

        class Network {
            // nodes is [], nodes[x] is node k from any layerIdx, its a function-lambda
            // layerIdxs [], layerIdxs[x] is amount of nodes in layerIdx x, sum of layerIdxs should be equal to nodes length
            // links is [[], ], links[x][y] is link from x to y if present
            constructor(middleLayerIdxFunction, outputLayerIdxFunction, layers, links) {
                this.frontLayerFunction = (i) => i;
                this.middleLayerIdxFunction = middleLayerIdxFunction;
                this.outputLayerIdxFunction = outputLayerIdxFunction;
                this.layers = layers;
                this.links = links;
            }

            getNodeLayer(id) {
                let skipped = 0
                for (let layerIdx = 0; layerIdx < this.layers.length; layerIdx++) {
                    let layerSize = this.layers[layerIdx]
                    if (id < skipped + layerSize) {
                        return { "layerIdx": layerIdx, "layerNodeIdx": (id - skipped) }
                    }
                    skipped += layerSize
                }
            }

            trainSingle(input, response) {

            }

            calc(input) {
                if (input.length != this.layers[0]) {
                    console.log("Bad input")
                    return
                }

                let middleIn = Array.from({ length: this.layers[1] }, (v, i) => 0)
                for (let linkIdx = 0; linkIdx < this.links; linkIdx++) {
                    let link = this.links[linkIdx];
                    let startLayer = getNodeLayer(link[0])
                    if (startLayer.layerIdx != 0) continue;
                    let endLayer = getNodeLayer(link[1])
                    if (endLayer.layerIdx != 1) continue

                    middleIn[endLayer.layerNodeIdx] += link[2] * input[startLayer.layerNodeIdx]
                }

                //todo continue from here

                let middleOut = Array.from({ length: layers[1] }, (v, i) => 0)

                for (let layerIdx = 1; layerIdx < this.layers.length; layerIdx++) {
                    let layerInput = Array.from({ length: layers[layerIdx] }, (v, i) => 0)
                    let layerOutput = Array.from({ length: layers[layerIdx] }, (v, i) => 0)
                }
            }
        }

        let evaderNetwork = new Network(
            (input) => sign(input),
            (input) => sign(input),
            [3, 4, 2],
            [[0, 3, 1], [4, 7, 1]]
        )

        const accelStart = (e) => {
            switch (e.key) {
                case 'a':
                    invader.accel.x.negative = 1;
                    break;
                case 'd':
                    invader.accel.x.positive = 1;
                    break;
                case 'w':
                    invader.accel.y.positive = 1;
                    break;
                case 's':
                    invader.accel.y.negative = 1;
                    break;
                case ' ':
                    invader.gun.pressed = 1;
                    break;
            }
        };

        const accelStop = (e) => {
            switch (e.key) {
                case 'a':
                    invader.accel.x.negative = 0;
                    break;
                case 'd':
                    invader.accel.x.positive = 0;
                    break;
                case 'w':
                    invader.accel.y.positive = 0;
                    break;
                case 's':
                    invader.accel.y.negative = 0;
                    break;
                case ' ':
                    invader.gun.pressed = 0;
                    break;
            }
        };

        function makeShip(x, y, rot, color) {
            return {
                "pos": { "x": x, "y": y },
                "vel": { "x": 0, "y": 0 },
                "accel": {
                    "x": {
                        "positive": 0, "negative": 0
                    },
                    "y": {
                        "positive": 0, "negative": 0
                    }
                },
                "rotation_target": {
                    "x": 0, "y": 0
                },
                "rot": rot,
                "fillStyle": color,
                "gun": {
                    "pressed": 0,
                    "cooldown": 0
                }
            }
        }

        function makeBullet(x, y, velX, velY, color) {
            return {
                "pos": { "x": x, "y": y },
                "vel": { "x": velX, "y": velY },
                "size": bulletSize,
                "fillStyle": color
            }
        }

        var mouse_pos = { "x": 0, "y": 0 };

        var invader = makeShip(150, 200, Math.PI / 4, "red")
        var evader = makeShip(300, 300, Math.PI * 3 / 4, "blue")

        var bullets = []
        var bulletPoolIdx = 0
        var bullet = makeBullet(30, 30, 0, 0, "black");
        for (let i = 0; i < bulletPoolSize; i++) {
            bullets.push(makeBullet(-100, -100, 0, 0, "black"))
        }

        bullets.push(bullet)
        function drawShip(ctx, ship) {
            //console.log(ship)
            ctx.fillStyle = ship.fillStyle;
            ctx.save();
            ctx.translate(ship.pos.x, ship.pos.y);

            ctx.rotate(ship.rot);

            var path = new Path2D();
            path.moveTo(50, 0);
            path.lineTo(0, -20);
            path.lineTo(10, 0);
            path.lineTo(0, 20);
            ctx.fill(path);
            ctx.restore();
        }

        function drawBullet(ctx, bullet) {
            //console.log(bullet)
            ctx.save();
            ctx.translate(bullet.pos.x, bullet.pos.y);
            ctx.beginPath()
            ctx.arc(0, 0, bullet.size, 0, Math.PI * 2, false);
            ctx.fillStyle = bullet.fillStyle;

            //stroke will draw the circle
            ctx.fill()
            ctx.restore()
        }

        function drawBorder(ctx, canvas) {
            // set line stroke and line width
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;

            // draw a red line
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(canvas.width, 0);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.stroke();
        }

        function drawFrame() {

            // get the canvas element using the DOM
            var canvas = document.getElementById('frame-canvas');
            var dimension = [document.getElementById("frame-div").offsetWidth, document.getElementById("frame-div").offsetHeight];

            canvas.width = dimension[0];
            canvas.height = dimension[1];

            // Make sure we don't execute when canvas isn't supported
            if (canvas.getContext) {

                // use getContext to use the canvas for drawing
                var ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.transform(1, 0, 0, -1, 0, canvas.height) // flip y

                drawBorder(ctx, canvas);

                drawShip(ctx, invader);
                drawShip(ctx, evader);
                for (let i = 0; i < bullets.length; i++) {
                    drawBullet(ctx, bullets[i]);
                }
            } else {
                alert('Canvas.getContext not supported in your browser');
            }
        }

        function drawNetwork() {

            // get the canvas element using the DOM
            var canvas = document.getElementById('network-canvas');
            var dimension = [document.getElementById("network-div").offsetWidth, document.getElementById("network-div").offsetHeight];

            canvas.width = dimension[0];
            canvas.height = dimension[1];

            // Make sure we don't execute when canvas isn't supported
            if (canvas.getContext) {

                // use getContext to use the canvas for drawing
                var ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // ctx.transform(1, 0, 0, -1, 0, canvas.height) // flip y

                drawBorder(ctx, canvas);

                let network = evaderNetwork;
                for (var layerIdx = 0; layerIdx < network.layers.length; layerIdx++) {
                    let xShift = 50 * (layerIdx + 1)
                    for (var layerNodeIdx = 0; layerNodeIdx < network.layers[layerIdx]; layerNodeIdx++) {
                        let yShift = 50 * (layerNodeIdx + 1)
                        // console.log("draw node " + layerIdx + ":" + layerNodeIdx)
                        drawBullet(ctx, {
                            "pos": { "x": xShift, "y": yShift },
                            "size": annNodeSize,
                            "fillStyle": "black"
                        })
                    }
                }

                for (var linkIdx = 0; linkIdx < network.links.length; linkIdx++) {
                    let fromIdx = network.links[linkIdx][0]
                    let toIdx = network.links[linkIdx][1]
                    let from = network.getNodeLayer(fromIdx)
                    let to = network.getNodeLayer(toIdx)


                    // set line stroke and line width
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = Math.max(2, Math.log(network.links[linkIdx][2]));

                    // draw a red line
                    ctx.beginPath();
                    let xShift = 50 * (from.layerIdx + 1) + annNodeSize
                    let yShift = 50 * (from.layerNodeIdx + 1)
                    ctx.moveTo(xShift, yShift);
                    xShift = 50 * (to.layerIdx + 1) - annNodeSize
                    yShift = 50 * (to.layerNodeIdx + 1)
                    ctx.lineTo(xShift, yShift);
                    ctx.stroke();
                }
            } else {
                alert('Canvas.getContext not supported in your browser');
            }
        }

        function getMousePos(canvas, evt) {
            var rect = canvas.getBoundingClientRect(), // abs. size of element
                scaleX = canvas.width / rect.width,    // relationship bitmap vs. element for x
                scaleY = canvas.height / rect.height;  // relationship bitmap vs. element for y

            return {
                x: (evt.clientX - rect.left) * scaleX,   // scale mouse coordinates after they have
                y: rect.height - (evt.clientY - rect.top) * scaleY     // been adjusted to be relative to element
            }
        }

        let handleMousemove = (event) => {
            var shipCanvas = document.getElementById('frame-canvas');
            let mouseCanvas = getMousePos(shipCanvas, event)
            mouse_pos.x = mouseCanvas.x;
            mouse_pos.y = mouseCanvas.y;
            //reverse y as canvas has y 0 in the bottom left
            invader.rot = Math.atan2(mouseCanvas.y - invader.pos.y, mouseCanvas.x - invader.pos.x)
        };

        let throttle = (func, delay) => {
            let prev = Date.now() - delay;
            return (...args) => {
                let current = Date.now();
                if (current - prev >= delay) {
                    prev = current;
                    func.apply(null, args);
                }
            }
        };

        function getBullet(pos, vel, rot) {
            let b = bullets[bulletPoolIdx];
            bulletPoolIdx = (bulletPoolIdx + 1) % bulletPoolSize;
            b.pos.x = pos.x
            b.pos.y = pos.y
            b.vel.x = vel.x + bulletSpeed * Math.cos(rot);
            b.vel.y = vel.y + bulletSpeed * Math.sin(rot);
            return b
        }

        function handleGun(ship) {
            if (ship.gun.pressed && !ship.gun.cooldown) {
                let bullet = getBullet(ship.pos, ship.vel, ship.rot)
                ship.gun.cooldown = 1
            }
            if (!ship.gun.pressed) {
                ship.gun.cooldown = 0
            }
        }

        function handleInvader(ship) {
            accel_x = (-ship.accel.x.negative + ship.accel.x.positive) * maxInvaderAccelPerFrame
            accel_y = (-ship.accel.y.negative + ship.accel.y.positive) * maxInvaderAccelPerFrame
            ship.vel.x += accel_x
            ship.vel.y += accel_y
            ship.pos.x += ship.vel.x
            ship.pos.y += ship.vel.y
            ship.vel.x *= 0.95
            ship.vel.y *= 0.95

            if (Math.abs(ship.vel.x) < minInvaderSpeedPerFrame) ship.vel.x = 0
            if (Math.abs(ship.vel.y) < minInvaderSpeedPerFrame) ship.vel.y = 0

            ship.vel.x = Math.max(-maxInvaderSpeedPerFrame, Math.min(maxInvaderSpeedPerFrame, ship.vel.x));
            ship.vel.y = Math.max(-maxInvaderSpeedPerFrame, Math.min(maxInvaderSpeedPerFrame, ship.vel.y));

            ship.rot = Math.atan2(mouse_pos.y - ship.pos.y, mouse_pos.x - ship.pos.x)

            handleGun(ship)
        }

        function handleBullet(bullet) {
            bullet.pos.x += bullet.vel.x
            bullet.pos.y += bullet.vel.y
        }

        function logicFrame() {
            handleInvader(invader)
            for (let i = 0; i < bullets.length; i++) {
                handleBullet(bullets[i]);
            }
        }

        function frame() {
            logicFrame()
            drawFrame()

            evader.rot -= 2 * Math.PI / 60;
            bullet.pos.x += 1;
            drawNetwork()
        }

        function animate() {
            setInterval(() => { frame() }, msPerFrame);
            window.addEventListener('keydown', accelStart);
            window.addEventListener('keyup', accelStop);
            document.addEventListener('mousemove', throttle(handleMousemove, msPerFrame));
        }
    </script>
</head>

<body onload="animate();">
    <div id="frame-div" style="width: 400px; height: 400px;">
        <canvas id="frame-canvas"></canvas>
    </div>
    <div id="network-div" style="width: 400px; height: 400px;">
        <canvas id="network-canvas"></canvas>
    </div>
</body>

</html>