<!DOCTYPE html>
<html>

<head>
    <script type="text/javascript">
        let fps = 60
        let msPerFrame = 1000 / fps;

        class Network {
            // nodes is [], nodes[x] is node k from any layerIdx, its a function-lambda
            // layerIdxs [], layerIdxs[x] is amount of nodes in layerIdx x, sum of layerIdxs should be equal to nodes length
            // links is [[], ], links[x][y] is link from x to y if present
            constructor(middleLayerIdxFunction, outputLayerIdxFunction, layers, links) {
                this.frontLayerFunction = (i) => i;
                this.middleLayerIdxFunction = middleLayerIdxFunction;
                this.outputLayerIdxFunction = outputLayerIdxFunction;
                this.layers = layers;
                this.links = links;
            }

            getNodeLayer(id) {
                let skipped = 0
                for (let layerIdx = 0; layerIdx < this.layers.length; layerIdx++) {
                    let layerSize = this.layers[layerIdx]
                    if (id < skipped + layerSize) {
                        return { "layerIdx": layerIdx, "layerNodeIdx": (id - skipped) }
                    }
                    skipped += layerSize
                }
            }

            trainSingle(input, response) {
            }

            calc(input) {
                if (input.length != this.layers[0]) {
                    console.log("Bad input")
                    return
                }

                let middleIn = Array.from({ length: this.layers[1] }, (v, i) => 0)
                for (let linkIdx = 0; linkIdx < this.links; linkIdx++) {
                    let link = this.links[linkIdx];
                    let startLayer = getNodeLayer(link[0])
                    if (startLayer.layerIdx != 0) continue;
                    let endLayer = getNodeLayer(link[1])
                    if (endLayer.layerIdx != 1) continue

                    middleIn[endLayer.layerNodeIdx] += link[2] * input[startLayer.layerNodeIdx]
                }

                //todo continue from here

                let middleOut = Array.from({ length: layers[1] }, (v, i) => 0)

                for (let layerIdx = 1; layerIdx < this.layers.length; layerIdx++) {
                    let layerInput = Array.from({ length: layers[layerIdx] }, (v, i) => 0)
                    let layerOutput = Array.from({ length: layers[layerIdx] }, (v, i) => 0)
                }
            }
        }

        let evaderNetwork = new Network(
            (input) => sign(input),
            (input) => sign(input),
            [3, 4, 2],
            [[0, 3, 1], [4, 7, 1]]
        )

        const handleMovement = (e) => {

            let speed = 5

            switch (e.key) {
                case 'a':
                    invader.x -= speed;
                    break;
                case 'd':
                    invader.x += speed;
                    break;
                case 'w':
                    invader.y += speed;
                    break;
                case 's':
                    invader.y -= speed;
                    break;
            }
        };

        var invader = {
            "x": 150,
            "y": 200,
            "rot": Math.PI / 4,
            "fillStyle": "red"
        }
        var evader = {
            "x": 300,
            "y": 300,
            "rot": Math.PI * 3 / 4,
            "fillStyle": "blue"
        }
        var bullet = {
            "x": 30,
            "y": 30,
            "size": 10,
            "fillStyle": "black"
        }
        function drawShip(ctx, ship) {
            //console.log(ship)
            ctx.fillStyle = ship.fillStyle;
            ctx.save();
            ctx.translate(ship.x, ship.y);

            ctx.rotate(ship.rot);

            var path = new Path2D();
            path.moveTo(50, 0);
            path.lineTo(0, -20);
            path.lineTo(10, 0);
            path.lineTo(0, 20);
            ctx.fill(path);
            ctx.restore();
        }

        function drawBullet(ctx, bullet) {
            //console.log(bullet)
            ctx.save();
            ctx.translate(bullet.x, bullet.y);
            ctx.beginPath()
            ctx.arc(0, 0, bullet.size, 0, Math.PI * 2, false);
            ctx.fillStyle = bullet.fillStyle;

            //stroke will draw the circle
            ctx.fill()
            ctx.restore()
        }

        function drawBorder(ctx, canvas) {
            // set line stroke and line width
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1;

            // draw a red line
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(canvas.width, 0);
            ctx.lineTo(canvas.width, canvas.height);
            ctx.lineTo(0, canvas.height);
            ctx.stroke();
        }

        function drawFrame() {

            // get the canvas element using the DOM
            var canvas = document.getElementById('frame-canvas');
            var dimension = [document.getElementById("frame-div").offsetWidth, document.getElementById("frame-div").offsetHeight];

            canvas.width = dimension[0];
            canvas.height = dimension[1];

            // Make sure we don't execute when canvas isn't supported
            if (canvas.getContext) {

                // use getContext to use the canvas for drawing
                var ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.transform(1, 0, 0, -1, 0, canvas.height) // flip y

                drawBorder(ctx, canvas);

                drawShip(ctx, invader);
                drawShip(ctx, evader);
                drawBullet(ctx, bullet);
            } else {
                alert('Canvas.getContext not supported in your browser');
            }
        }

        function drawNetwork() {

            // get the canvas element using the DOM
            var canvas = document.getElementById('network-canvas');
            var dimension = [document.getElementById("network-div").offsetWidth, document.getElementById("network-div").offsetHeight];

            canvas.width = dimension[0];
            canvas.height = dimension[1];

            // Make sure we don't execute when canvas isn't supported
            if (canvas.getContext) {

                // use getContext to use the canvas for drawing
                var ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                // ctx.transform(1, 0, 0, -1, 0, canvas.height) // flip y

                drawBorder(ctx, canvas);

                let network = evaderNetwork;
                for (var layerIdx = 0; layerIdx < network.layers.length; layerIdx++) {
                    let xShift = 50 * (layerIdx + 1)
                    for (var layerNodeIdx = 0; layerNodeIdx < network.layers[layerIdx]; layerNodeIdx++) {
                        let yShift = 50 * (layerNodeIdx + 1)
                        // console.log("draw node " + layerIdx + ":" + layerNodeIdx)
                        drawBullet(ctx, {
                            "x": xShift,
                            "y": yShift,
                            "size": 10,
                            "fillStyle": "black"
                        })
                    }
                }

                for (var linkIdx = 0; linkIdx < network.links.length; linkIdx++) {
                    let fromIdx = network.links[linkIdx][0]
                    let toIdx = network.links[linkIdx][1]
                    let from = network.getNodeLayer(fromIdx)
                    let to = network.getNodeLayer(toIdx)


                    // set line stroke and line width
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 5;

                    // draw a red line
                    ctx.beginPath();
                    let xShift = 50 * (from.layerIdx + 1)
                    let yShift = 50 * (from.layerNodeIdx + 1)
                    ctx.moveTo(xShift, yShift);
                    xShift = 50 * (to.layerIdx + 1)
                    yShift = 50 * (to.layerNodeIdx + 1)
                    ctx.lineTo(xShift, yShift);
                    ctx.stroke();
                }
            } else {
                alert('Canvas.getContext not supported in your browser');
            }
        }

        function getMousePos(canvas, evt) {
            var rect = canvas.getBoundingClientRect(), // abs. size of element
                scaleX = canvas.width / rect.width,    // relationship bitmap vs. element for x
                scaleY = canvas.height / rect.height;  // relationship bitmap vs. element for y

            return {
                x: (evt.clientX - rect.left) * scaleX,   // scale mouse coordinates after they have
                y: rect.height - (evt.clientY - rect.top) * scaleY     // been adjusted to be relative to element
            }
        }

        let handleMousemove = (event) => {
            var shipCanvas = document.getElementById('frame-canvas');
            let mouseCanvas = getMousePos(shipCanvas, event)
            //reverse y as canvas has y 0 in the bottom left
            invader.rot = Math.atan2(mouseCanvas.y - invader.y, mouseCanvas.x - invader.x)
        };

        let throttle = (func, delay) => {
            let prev = Date.now() - delay;
            return (...args) => {
                let current = Date.now();
                if (current - prev >= delay) {
                    prev = current;
                    func.apply(null, args);
                }
            }
        };

        function frame() {
            drawFrame()
            //invader.rot += 2 * Math.PI / 60;
            evader.rot -= 2 * Math.PI / 60;
            bullet.x += 1;
            drawNetwork()
        }

        function animate() {
            setInterval(() => { frame() }, msPerFrame);
            window.addEventListener('keydown', handleMovement);
            document.addEventListener('mousemove', throttle(handleMousemove, msPerFrame));
        }
    </script>
</head>

<body onload="animate();">
    <div id="frame-div" style="width: 400px; height: 400px;">
        <canvas id="frame-canvas"></canvas>
    </div>
    <div id="network-div" style="width: 400px; height: 400px;">
        <canvas id="network-canvas"></canvas>
    </div>
</body>

</html>